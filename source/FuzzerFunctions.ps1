#  Copyright 2025 Remco van der Meer. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

<#
.SYNOPSIS
Invokes the COM Fuzzer
.DESCRIPTION
This cmdlet invokes the fuzzing process, will need the ComServerData.json file as input, which was generated by Get-ComServerData.
.PARAMETER DataFile
Specify the json file that was generated by Get-ComServerData
.PARAMETER Output
Specify the output directory for the fuzzing results
.PARAMETER Timeout
Specify the timeout in seconds for COM procedure invocations (default: 5)
.INPUTS
JSON file
.OUTPUTS
JSON file
.EXAMPLE
'.\ComServerData.json' | Invoke-ComFuzzer -OutPath .\output\
Fuzzing with no options
.EXAMPLE
'.\ComServerData.json' | Invoke-ComFuzzer -OutPath .\output\ -UNC 172.22.13.110
Specify IPv4 for testing UNC paths vulnerabilities (relay attack vectors)
.EXAMPLE
'.\ComServerData.json' | Invoke-ComFuzzer -OutPath .\output\ -minStrLen 100 -maxStrLen 200
Specify length for Strings
.EXAMPLE
'.\ComServerData.json' | Invoke-ComFuzzer -OutPath .\output\ -minIntSize 10 -maxIntSize 20
Specify size for Integers
.EXAMPLE
'.\ComServerData.json' | Invoke-ComFuzzer -OutPath .\output\ -Iterations 5
Invoke every procedure 5 times
.EXAMPLE
'.\ComServerData.json' | Invoke-ComFuzzer -OutPath .\output\ -Timeout 10
Set timeout to 10 seconds for COM procedure invocations
#>
function Invoke-ComFuzzer {
    param (
        [Parameter(ValueFromPipeline = $true, Mandatory = $true)]
        [string]$ComDataFile,
        [int32]$minStrLen = 20,
        [int32]$maxStrLen = 30,
        [string]$StringInput,
        [int32]$minIntSize = -2147483648,
        [int32]$maxIntSize = 2147483647,
        [guid]$GuidInput,
        [int32]$IntInput,
        [string]$UNC,
        [Parameter(Mandatory = $true)]
        [string]$OutPath,
        [switch]$NoSpecialChars,
        [string]$Blacklist,
        [string]$Procedure,
        [int]$Iterations = 1,
        [string]$Canary = "incendium",
        [string]$RemoteServer,
        [string]$Username,
        [string]$Password,
        [string]$Domain,
        [string[]]$Skip,
        [int]$Timeout = 5
    )

    $excludedMethods = @(
        'Connect', 'Disconnect', 'Dispose', 'Equals', 'GetHashCode',
        'GetType', 'QueryInterface', 'ToString', 'Unwrap'
    )    

    # Check if a blacklist is parsed
    if ($Blacklist) {
        $Blacklist = Get-Content $Blacklist
    }

    # Read and parse the JSON array from the file
    $ComDataEntries = Get-Content -Path $ComDataFile -Raw | ConvertFrom-Json

    # Ensure output path exists
    if (-not (Test-Path $OutPath)) {
        New-Item -ItemType Directory -Path $OutPath | Out-Null
    }

    $index = 0
    $total = $ComDataEntries.Count
    foreach ($ComClassEntry in $ComDataEntries) {
        if ($Blacklist) {
            if ($Blacklist -imatch $ComClassEntry.CLSID) {
                Continue
            }
        }
        $index++
        # Show progress bar
        if ($total -lt 2) {
            $total = 2
        }
        Write-Progress -Activity "Fuzzing COM Classes" `
                    -Status "Fuzzing $($ComClassEntry.CLSID)" `
                    -PercentComplete (($index / $total) * 100)

        # Attempt to find the class in the system registry
        $ComClass = Get-ComClass -Clsid $ComClassEntry.CLSID
        if (-not $ComClass) {
            Write-Warning "[-] CLSID $($ComClassEntry.CLSID) not found on this system."
            continue
        }

        try {
            if ($RemoteServer) {
                $creds = Get-ComCredentialCustom -Username $Username -Password $Password -Domain $Domain
                $credsobj = Get-ComAuthInfo -AuthIdentityData $creds
                $IntObj = New-ComObject -Class $ComClass -RemoteServer $RemoteServer -AuthInfo $credsobj
            } else {
                $IntObj = New-ComObject -Class $ComClass
            }
        } catch {
            Write-Verbose "[!] Failed to create COM object for $($ComClassEntry.ClassName): $_"
            continue
        }

        foreach ($ComClassInterfaceEntry in $ComClassEntry.Interfaces) {
            try {
                $ComClient = Get-ComObjectInterface -Object $IntObj -Iid $ComClassInterfaceEntry.IID

                if ($ComClient) {
                    # Filter away the unnecessary COM procedures

                    if ($Procedure) {
                        # User wants to fuzz specific COM procedure
                        $ComProcedures = $ComClient | Get-Member -MemberType Method | Where-Object {
                            ($excludedMethods -notcontains $_.Name) -and
                            (-not $_.Name.StartsWith('get_')) -and
                            (-not $_.Name.StartsWith('set_')) -and $_.Name -eq $Procedure
                        }                        
                    } else {
                        $ComProcedures = $ComClient | Get-Member -MemberType Method | Where-Object {
                            ($excludedMethods -notcontains $_.Name) -and
                            (-not $_.Name.StartsWith('get_')) -and
                            (-not $_.Name.StartsWith('set_'))
                        }                        
                    }
                    foreach ($ComProcedure in $ComProcedures) {
                        for ($i = 0; $i -lt $Iterations; $i++) {
                            try {
                                # Extract method name and definition string
                                $methodName = $ComProcedure.Name
                                $definition = $ComProcedure.Definition

                                # Wrap definition as a method object
                                $fakeMethod = [PSCustomObject]@{ Definition = $definition }

                                # Format Parameters
                                $params = Format-DefaultParameters -ComMethod $fakeMethod -minStrLen $minStrLen -maxStrLen $maxStrLen -StringInput $StringInput -GuidInput $GuidInput -IntInput $IntInput -UNC $UNC -canary $Canary -minIntSize $minIntSize -maxIntSize $maxIntSize
                                $inputResult = if ($params.Count -gt 0) {($params -join ", ")}  else { "No input" }
                                $inputResult = $inputResult.replace('"', '')

                                    $comClassId = $ComClassEntry.CLSID
                                    $comIntId = $ComClassInterfaceEntry.IID
                                    $logEntry = "COM Class: $comClassId `nInterface: $comIntId `nProcedure: $ComProcedure `nParams: $inputResult`n------------------------`n"
                                    $logFilePath = "$OutPath\log.txt"
                                    $logEntry | Out-File -FilePath $logFilePath -Append -Encoding utf8

                                # Invoke Procedure with timeout
                                $result = Invoke-ComProcedureWithTimeout -ComClient $ComClient -ComProcedure $methodName -Params $params -Timeout $Timeout -Skip $Skip

                                # Check if timeout occurred
                                if ($result -eq "TIMEOUT") {
                                    Write-Verbose "[!] Timeout occurred for $methodName after $Timeout seconds"
                                    
                                    # Log timeout
                                    $timeoutLogEntry = "TIMEOUT: COM Class: $comClassId, Interface: $comIntId, Procedure: $methodName`n"
                                    $timeoutLogEntry | Out-File -FilePath "$OutPath\timeouts.txt" -Append -Encoding utf8
                                    
                                    continue
                                }

                                # Check first if output has properties
                                if ($result.PSObject.Properties.MemberType) {
                                    $allOutputResult = $result | Get-Member -MemberType Properties | ForEach-Object {
                                        $value = ($result.$($_.Name)) -replace '"', ''
                                        if ($value -ne '') {
                                            "$($_.Name): $($value)"
                                        } else {
                                            "$($_.Name): N/A"
                                        }
                                    }
                                } else {
                                    $allOutputResult = $result -replace '"', ''
                                }
        
                                # Loop over each output result
                                foreach ($value in $allOutputResult) {
                                    if ($value -match 'retval') {
                                        $value = $value.replace('retval: ', '')
                                    } 
                                    try {
                                        # Check if the result is a Windows message
                                        $windowsMessage = [System.ComponentModel.Win32Exception]::new([Int]($value)).Message
                                        if ($windowsMessage -ne $value) {
                                            # Output is a windows message
                                            $windowsMessage = "$("{0:X}" -f ($value -band 0xFFFFFFFF)): $windowsMessage"
                                        } else {
                                            $windowsMessage = "No Windows Message"
                                        }
                                    } catch {
                                        $windowsMessage = "No Windows Message"
                                    }
                                }

                                # See if class is attached to a Windows service
                                if ($ComClass.AppIDEntry) {
                                    $service = $ComClass.AppIDEntry
                                } elseif ($ComClass.TypeLibEntry) {
                                    $service = $ComClass.TypeLibEntry
                                } else {
                                    $service = "N/A"
                                }
        
                                $outputResult = $allOutputResult

                                # Check if Windows message is access denied
                                if ($windowsMessage -imatch "Access is denied") {
                                    # Export the fuzzing results
                                    Export-AccessDeniedInput -ProcedureName $methodName `
                                                            -ComServerName $ComClassEntry.Name `
                                                            -ComCLSID $ComClassEntry.CLSID `
                                                            -ComInterface $ComClassInterfaceEntry.IID `
                                                            -Service $service `
                                                            -ProcedureDefinition $definition `
                                                            -FuzzInput $inputResult `
                                                            -Output $outputResult `
                                                            -windowsMessage $windowsMessage `
                                                            -OutPath $OutPath `
                                } else {
                                    # Export the fuzzing results
                                    Export-AllowsFuzzedInput -ProcedureName $methodName `
                                                            -ComServerName $ComClassEntry.Name `
                                                            -ComCLSID $ComClassEntry.CLSID `
                                                            -ComInterface $ComClassInterfaceEntry.IID `
                                                            -Service $service `
                                                            -ProcedureDefinition $definition `
                                                            -FuzzInput $inputResult `
                                                            -Output $outputResult `
                                                            -windowsMessage $windowsMessage `
                                                            -OutPath $OutPath `
                                }
                            } catch {
                                Write-Verbose "Could not invoke method $methodName": $_
                            }
                        }
                    }
                } else {
                    Write-Warning "Could not bind to ComClass"
                }
            }
            catch {
                Write-Verbose "Exception while accessing interface: $_"
            }
        }
    }
}

<#
.SYNOPSIS
Function used to invoke a COM procedure with timeout
.DESCRIPTION
This function is used to invoke the COM procedure by creating a method object and invoking it dynamically with a timeout
#>
Function Invoke-ComProcedureWithTimeout {
    param (
        [Parameter(Mandatory = $true)]
        $ComClient,

        [Parameter(Mandatory = $true)]
        [string]$ComProcedure,

        [object[]]$Params,

        [int]$Timeout = 5,

        [string[]]$Skip
    )

    try {
        # Get the method
        $method = $ComClient.PSObject.Methods | Where-Object { $_.Name -eq $ComProcedure }
        if (-not $method) {
            throw "Method '$ComProcedure' not found on COM object."
        }

        # Skip if in skip list
        if ($Skip -contains $ComProcedure) {
            return $null
        }

        # Create a PowerShell runspace to execute with timeout
        $runspace = [runspacefactory]::CreateRunspace()
        $runspace.Open()
        
        # Pass the COM client to the runspace
        $runspace.SessionStateProxy.SetVariable("ComClient", $ComClient)
        $runspace.SessionStateProxy.SetVariable("ComProcedure", $ComProcedure)
        $runspace.SessionStateProxy.SetVariable("Params", $Params)

        # Create PowerShell instance
        $powershell = [powershell]::Create()
        $powershell.Runspace = $runspace

        # Script to invoke the method
        $scriptBlock = {
            try {
                $method = $ComClient.PSObject.Methods | Where-Object { $_.Name -eq $ComProcedure }
                if ($Params.Length -eq 0) {
                    return $method.Invoke()
                } else {
                    return $method.Invoke($Params)
                }
            } catch {
                throw $_
            }
        }

        [void]$powershell.AddScript($scriptBlock)

        # Start async execution
        $asyncResult = $powershell.BeginInvoke()

        # Wait for completion or timeout
        $completed = $asyncResult.AsyncWaitHandle.WaitOne([TimeSpan]::FromSeconds($Timeout))

        if ($completed) {
            # Method completed within timeout
            $result = $powershell.EndInvoke($asyncResult)
            $powershell.Dispose()
            $runspace.Close()
            $runspace.Dispose()
            return $result
        } else {
            # Timeout occurred
            Write-Verbose "Timeout occurred for $ComProcedure"
            $powershell.Stop()
            $powershell.Dispose()
            $runspace.Close()
            $runspace.Dispose()
            return "TIMEOUT"
        }

    } catch {
        #Write-Verbose "Error invoking $ComProcedure : $_"
        return $null
    }
}

<#
.SYNOPSIS
Function used to invoke a COM procedure (legacy version without timeout)
.DESCRIPTION
This function is used to invoke the COM procedure by creating a method object and invoking it dynamically
#>
Function Invoke-ComProcedure {
    param (
        [Parameter(Mandatory = $true)]
        $ComClient,

        [Parameter(Mandatory = $true)]
        [string]$ComProcedure,

        [object[]]$Params
    )

    try {
        # Get the method and invoke it dynamically
        $method = $ComClient.PSObject.Methods | Where-Object { $_.Name -eq $ComProcedure }
        if (-not $method) {
            throw "Method '$ComProcedure' not found on COM object."
        }

        # Call the method with unpacked parameters
        if ($Skip -notcontains $ComProcedure) {
            if ($Params.Length -eq 0) {
                return $method.Invoke()
            } else {
                return $method.Invoke($Params)
            }
        }
    } catch {
        #Write-Verbose "Error invoking $ComProcedure : $_"
    }
}

<#
.SYNOPSIS
Gets credentials.
.DESCRIPTION
This cmdlet gets a set of user credentials from the console.
.INPUTS
None
.OUTPUTS
OleViewDotNet.Security.COMCredentials
#>
function Get-ComCredentialCustom {
    param (
        $Username,
        $Password,
        $Domain
    )
    $Pass = ConvertTo-SecureString -String $Password -AsPlainText -Force
    $creds = [OleViewDotNet.Security.COMCredentials]::new()
    $creds.UserName = $Username
    $creds.Domain = $Domain
    $creds.Password = $Pass
    $creds
}